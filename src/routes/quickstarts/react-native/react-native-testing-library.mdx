# Mock Network Requests in React Native Testing Library with Mirage

Use your Mirage server to test your React Native application under different server scenarios using [React Native Testing Library](https://github.com/testing-library/native-testing-library) and [Jest Native](https://github.com/testing-library/jest-native).

> This is a quickstart guide should also work for people using [`react-test-renderer`](https://reactjs.org/docs/test-renderer.html) or [`react-native-testing-library`](https://github.com/callstack/react-native-testing-library).

## Step 1: Install Mirage

First, make sure you have Mirage installed:

```bash
# Using npm
npm install --save-dev miragejs

# Using Yarn
yarn add --dev miragejs
```

## Step 2: Setup your testing environment

Out of the box, React Native does a good job to polyfill browser API's that we might need in libraries that were originally built to run on the browser. Our problem when using Mirage in a Jest testing environment is that we don't have access to some properties that the browser provides by default. To get around this issue we must update Jest's environment immediately after its setup is finished.

To update your Jest environment follow these steps:

1. Create a setup file in the root of your project. For the purpose of this guide we'll call it `jest.setup.js`.

2. Install a polyfill for XMLHttpRequest:

```bash
# Using npm
npm install --save-dev xmlhttprequest

# Using Yarn
yarn add --dev xmlhttprequest
```

3. Patch the variable `global` in your `jest.setup.js` to add support for XMLHttpRequest, self and window.

```js
// jest.setup.js
global.self = global;
global.window = {};
global.XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
```

4. Tell Jest to load the environment that we've created by adding the [`setupFilesAfterEnv`](https://jestjs.io/docs/en/configuration.html#setupfilesafterenv-array) to your Jest configuration. We must add `jest.setup.js` as an item in the list of files that Jest must execute after setting up its environment.

> Your jest configuration can be found on your package.json or in the root of your project with the name `jest.config.js`.

```js
// jest.config.js
const jestPreset = require('@testing-library/react-native/jest-preset');

module.exports = {
  preset: '@testing-library/react-native',
  setupFiles: [...jestPreset.setupFiles],
  setupFilesAfterEnv: ['./jest.setup.js'],
};
```

## Step 3: Define your server

Create a new `server.js` file and define your mock server.

Here's a basic example:

```js
// src/server.js
import { Server, Model } from "miragejs"

export function makeServer({ environment = "development", trackRequests = false } = {}) {
  let server = new Server({
    environment,
    trackRequests,

    models: {
      user: Model,
    },

    seeds(server) {
      server.create("user", { name: "Bob" })
      server.create("user", { name: "Alice" })
    },

    routes() {
      this.namespace = "api"

      this.get("/users", schema => {
        return schema.users.all()
      })
    },
  })

  return server
}
```

> In a React Native App, put this file in `src/mirage/server.js` so that changes to it trigger rebuilds.

## Step 4: Create a test file that uses Mirage

Here's the component we'll be testing.

```jsx
// src/App.js
import React, {useEffect, useState} from 'react';
import {SafeAreaView, View, Text} from 'react-native';

const App = () => {
  let [users, setUsers] = useState([]);
  let [serverError, setServerError] = useState();

  useEffect(() => {
    let fetchUsers = async () => {
      try {
        let res = await fetch('http://localhost:3000/v1/api/users');
        let data = await res.json();

        if (!res.ok) {
          throw data;
        }

        setUsers(data.users);
      } catch (error) {
        setServerError(error.error);
      }
    };

    fetchUsers();
  }, []);

  if (serverError) {
    return (
      <SafeAreaView style={{flex: 1}} testID="server-error">
        <Text testID="server-error-message">{serverError}</Text>
      </SafeAreaView>
    );
  }

  return users.length === 0 ? (
    <SafeAreaView style={{flex: 1}} testID="empty-users">
      <Text>No users have been found!</Text>
    </SafeAreaView>
  ) : (
    <SafeAreaView style={{flex: 1}} testID="user-list">
      {users.map(user => {
        return (
          <View key={user.id}>
            <Text>{user.name}</Text>
          </View>
        );
      })}
    </SafeAreaView>
  );
};

export default App;
```

Create a new `src/__tests__/App.test.js` file, import your `makeServer` function, and start and shutdown Mirage using `beforeEach` and `afterEach`, making sure to pass the `test` environment to Mirage:

```js
// src/__tests__/App.test.js
import React from "react"
import { render, waitForElement } from "@testing-library/react"
import App from "../App"
import { makeServer } from "../server"

let server

beforeEach(() => {
  server = makeServer({ environment: "test" })
})

afterEach(() => {
  server.shutdown()
})
```

## Step 5: Write tests using your Mirage server

Use your tests to seed Mirage with different data scenarios, then assert against the state of your UI.

> In the `test` environment, Mirage doesn't load its database `seeds`, so that the server starts out empty for each test run.

```js
it('renders the list of users from the server', async () => {
  // Add user data to the mirage db
  server.create('user', {name: 'Bob'});
  server.create('user', {name: 'Alice'});

  let {getByTestId} = render(<App />);

  await wait(() => expect(getByTestId('empty-users')).not.toBeEmpty());

  await wait(() => {
    // Verify the number of requests handled by pretender.
    let requests = server.pretender.handledRequests;

    expect(getByTestId('user-list')).not.toBeEmpty();
    expect(requests).toHaveLength(1);
  });
});
```

## Step 6: Alter your Mirage server to test different server states

In addition to different data scenarios, you can use your tests to reconfigure your Mirage server to test new situations.

For example, you can test an error state like this:

```js
// src/__tests__/App.test.js
import { Response } from "miragejs"

it('should handle server errors', async () => {
  let message = 'Internal Server error.';

  // Set a network error response on Mirage.
  server.get('/users', () => {
    return new Response(500, {}, {error: message});
  });

  let {getByTestId, debug} = render(<App />);

  await wait(() => expect(getByTestId('empty-users')).not.toBeEmpty());

  await wait(() => {
    expect(getByTestId('server-error')).not.toBeEmpty();
    expect(getByTestId('server-error-message')).toHaveTextContent(message);

    // Verify the number of requests handled by pretender.
    let requests = server.pretender.handledRequests;

    expect(requests).toHaveLength(1);
  });
});
```

Because of the way we setup Mirage using `beforeEach` and `afterEach`, each test will get a fresh Mirage server based on your main server definition. Any overrides you make within a test will be isolated to that test.

To see a full working example go [here](https://github.com/eluciano11/react-native-mirage).
